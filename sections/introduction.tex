\section{Introduction}
Unlike its classical counterpart, finiteness in constructive mathematics is a
rich and complex subject.
Classically, something is ``finite'' if it has a cardinality equal to some
natural number; every notion of finiteness is equivalent to this one.
Constructively, however, there are multiple distinct notions of finiteness, each
with interesting properties~\citep{coquandConstructivelyFinite2010,
  firsovVariationsNoetherianness2016, fruminFiniteSetsHomotopy2018}.

Part of the reason for different notions of finiteness in constructive
mathematics is that constructive proofs tend to be ``leaky''; as mathematical
objects, they tend to reveal some information about \emph{how} they were proven,
where a proof of a classical proposition only reveals that the proposition is
true.
Recent developments in type
theory~\citep[in particular Cubical Agda][]{vezzosiCubicalAgdaDependently2019}
have made constructions like propositional truncation more available, which
allow constructive proofs to patch this ``leak''; rather than making classical
and constructive proofs the same, however, this only makes their differences
more subtle.

All of our work will be formalised in Agda
\citep{norellDependentlyTypedProgramming2008}, a
dependently typed, pure, functional programming language which can be
used as a proof assistant.
A recent extension to Agda, Cubical Agda
\citep{vezzosiCubicalAgdaDependently2019}, allows Agda to compile and typecheck
programs written in Cubical Type Theory \citep{cohenCubicalTypeTheory2016}: this
type theory gives a \emph{computational} interpretation of the univalence axiom
\citep{hottbook}.
By ``computational interpretation'' here we mean that we will be able to run the
programs we write which rely on this axiom.
The univalence axiom allows us to do Homotopy Type Theory (HoTT) in Agda.

\subsection{Overview}
In Section~\ref{finiteness-predicates} we will look in-depth at the focus of
this paper: finiteness.
As mentioned finiteness in constructive mathematics is a good deal more complex
than finiteness classically:
in this paper alone we will see five separate definitions of ``finiteness''.
We will see which predicates imply each other, what extra information we can
derive from the predicates, and what types are included or excluded from each.
Along the way we will learn a little more about HoTT and univalence, and we'll
see some direct uses of the univalence axiom.

In Section~\ref{topos} we will look a little at a slightly more advanced
application of HoTT:\@ topos theory.
A topos is quite a complex, abstract object: it behaves something like the
category of sets, although it is more general.
We will show that finite sets in HoTT form a $\Pi$-pretopos.

In Section~\ref{search} we will present a library for finite proof search.
We will demonstrate the library with the countdown problem
\citep{huttonCountdownProblem2002}: this is a puzzle where
players are given five numbers and a target, and have to construct an expression
using some or all of the supplied numbers which evaluates to the target.

\subsection{Contributions}
\begin{description}
  \item[A classification of five finiteness predicates in Cubical Type Theory.]
    Four of these predicates have been previously defined and described in
    Homotopy Type Theory \citep{fruminFiniteSetsHomotopy2018}, and two in
    Martin-Löf type theory \citep{fruminFiniteSetsHomotopy2018}, this work defines
    the same predicates in the slightly different setting of Cubical Type
    Theory.
    This has the advantage of giving the proofs computational content, a feature
    used in Section~\ref{search}.
  \item[Proof of implication between finiteness predicates.]
    Some of these proofs have been seen in the literature before (from
    cardinal finiteness to manifest Bishop finiteness is present informally
    in~\cite{yorgeyCombinatorialSpeciesLabelled2014}, and formally (though in
    HoTT) in~\cite{fruminFiniteSetsHomotopy2018}).
    \Cref{cardinal-to-manifest-bishop} in particular is new, to the best
    of our knowledge.
  \item[Proof of relation between listed and \(\AgdaDatatype{Fin}\)-based
    finiteness predicates.]
    There are broadly two different ways to define finiteness predicates:
    through a list-based approach, or through relations with a finite prefix of the
    natural numbers.
    Our container-based treatment of the finiteness predicates  allows us to
    prove that the two forms of the predicates are equivalent.
  \item[Proof that Sets form a \(\Pi\)-Pretopos.]
    This is a proof that has been presented before, in both~\citet{hottbook}
    and~\citet{rijkeSetsHomotopyType2015}: here we present a machine-checked
    version of this proof.
  \item[Proof that Kuratowski Finite Sets form a \(\Pi\)-Pretopos
    (\Cref{kuratowski-topos}).]
  \item[A library for proof search.]
    While several libraries for proof search based on finiteness exist in
    dependently-typed programming languages
    \citep{firsovDependentlyTypedProgramming2015}, the one that is presented
    here is strictly more powerful than those that came before as it is capable
    of including functions in the search space.
    This is a direct consequence of the use of Cubical Type Theory: in MLTT
    functions would not be able to be included at all, and in HoTT the
    univalence axiom would not have computational content, so a proof search
    library (structured in the way presented here) would not function.
    There are other more minor contributions of this library: they are described
    in detail in subsection~\ref{search}.
  \item[A verified solver for the countdown problem.]
    The countdown problem \citep{huttonCountdownProblem2002} has been studied
    from a number of angles in functional
    programming~\cite{birdCountdownCaseStudy2005}; our solver is the first 
    machine-checked solver, to the best of our knowledge.
\end{description}

\subsection{Homotopy Type Theory}
HoTT is both a type theory and a foundational theory for mathematics.
As a type theory it can be thought of as an alternative to things like
Martin-Löf type theory; as a foundational theory it can be compared to other
foundational theories like Zermelo–Fraenkel set theory.
\begin{comment}
\begin{definition}[ZFC]
  Zermelo-Fraenkel set theory with choice is a foundational theory for
  mathematics, which is based on set theory.
  It is the most commonly-used foundational theory (although it is important to
  stress that most modern mathematics is foundation-agnostic).

  The Axiom of Choice is a non-constructive axiom which is independent of the
  rest of Zermelo-Fraenkel set theory: when included the theory is often
  abbreviated to ``ZFC''.

  A full exploration of ZFC and its axioms is beyond the scope of this paper;
  we will, see, however, a definition of the axiom of choice in CuTT
  (\Cref{axiom-of-choice}).
\end{definition}
\end{comment}

Central to the theory is the univalence axiom.
This axiom states that isomorphism implies equality: more precisely, that
``equivalence'' is equivalent to equality.
We haven't defined equivalence yet (and we haven't defined equality rigorously
yet), but the core thrust of the axiom is that it gives proofs of isomorphism
all the power of proofs of equality.

The other addition that HoTT gives to traditional type theory is that of Higher
Inductive Types.
Traditional inductive types are defined by listing their constructors: with HITs
we can also list the equalities they must satisfy.
The most obvious immediate use of this is quotient types,
but in HoTT they can be used of for much more exotic constructions like the
torus etc.

Finally, we have to explain where Cubical Type Theory
\citep{cohenCubicalTypeTheory2016} fits in.
Strictly speaking in this paper we will not work directly in HoTT: we work
instead in CuTT, which is very closely related, but not quite the same, as HoTT.
CuTT's main departure from HoTT is in its representation of equalities, which it
calls ``paths''.
In HoTT equalities are an inductive type.
In CuTT, paths behave like functions from the real line: an equality
\(x \equiv y\) is a function which, when applied to \(0\), returns \(x\), and
when applied to \(1\), returns \(y\).
\begin{equation}
\begin{aligned}
  & e  :    & x \equiv y \\
  & e(i) = & \begin{cases}
    x, & i = 0 \\
       & \vdots \\
    y, & i = 1
  \end{cases}
\end{aligned}
\end{equation}
This different ``implementation'' of paths is central to how CuTT can give
computational content to univalence, but it also slightly changes the way paths
function.

There is one crucial difference between the two theories: in CuTT the
univalence ``axiom'' is in fact a theorem, with computational content.
This means that univalence is not a built-in, assumed to be true, but instead
it's actually derived from other axioms in the system.
Practically speaking it means that univalence has computational content: i.e. if
we see that two types are equal then we can actually derive the isomorphism that
that equality implies.
As we're using CuTT as a programming language (in the form of Cubical Agda
\citep{vezzosiCubicalAgdaDependently2019}), this is an essential feature.
It means that the proofs we write using univalence still correspond to programs
which can be run.

\footnotetext{
  To be absolutely correct we should not say that CuTT implements HoTT, as the
  two have some subtle differences.
  While everything we can prove in HoTT can also be proven in CuTT,
  it is not the case that one is a strict subset of the other.
  CuTT has many of the same features of HoTT, like HITs and univalence, so
  almost all of the theory of HoTT applies to both (and indeed almost all of the
  univalent foundations program applies to both), but there are some slight
  differences between the theories which mean that some proofs which are valid
  HoTT are not valid in CuTT.
}
