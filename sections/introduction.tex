\chapter{Introduction}
% \begin{agdalisting}
%   \ExecuteMetaData[agda/Snippets/Interactive.tex]{step1}
% \end{agdalisting}
% \begin{agdalisting}
%   \ExecuteMetaData[agda/Snippets/Interactive.tex]{step2}
% \end{agdalisting}
% \begin{agdalisting}
%   \ExecuteMetaData[agda/Snippets/Interactive.tex]{step3}
% \end{agdalisting}

% \begin{equation}
%   \frac{
%     \mathit{zs}:\AgdaDatatype{List}\;A \;\;\;\;
%     \mathit{ys}:\AgdaDatatype{List}\;A \;\;\;\;
%     A :\AgdaDatatype{Type}\;a\;\text{(not in scope)} \;\;\;\;
%     a :\AgdaDatatype{Level}\;\text{(not in scope)}
%     }{
%     \mathit{ys}\;\AgdaFunction{++}\;\mathit{zs}
%     \;\AgdaFunction{≡}\;
%     \mathit{ys}\;\AgdaFunction{++}\;\mathit{zs}
%   }
% \end{equation} 

This thesis will explore and explain finiteness in constructive
mathematics: using this setting, it will also serve as an introduction to
constructive mathematics in Cubical Agda
\citep{vezzosiCubicalAgdaDependently2019}, and some related topics.

In constructive mathematics proofs are much more substantial things than their
classical counterparts.
A constructive proof is a mathematical object that can be manipulated in the
same way that an integer or an algorithm can: indeed, some of the ``proofs'' we
will see in this thesis will emerge to be useful programs in disguise.

Finiteness is one of the clearest examples which demonstrates this difference
between classical and constructive proofs.
There are several different ways to prove that something is finite: you could
show that it's in bijection with another finite type, or that there's a
surjection from the same, etc.
Classically speaking, all of these different proofs end up proving the same
thing: that the type in question is finite.
Constructively, however, these proofs are different: while we know that a type
with a surjection from a finite type must also have a bijection from that type
there's no way to \emph{provide} such a bijection, so constructively these
proofs are not equivalent.
As it happens there's a wide assortment of predicates which all have some claim
to being the formal interpretation of ``finiteness'', and they're all different
in a constructive setting \citep{coquandConstructivelyFinite2010}.

An exploration of finiteness also provides ample opportunity to explain much of
the fundamentals of Homotopy Type Theory \citep{hottbook}: this theory is a
foundational system for mathematics, which has at its core the \emph{univalence
  axiom}.
We will dive much more into this axiom later on, but for now know that it gives
a formal grounding to say ``if two types are isomorphic, it is possible to treat
them as the same.''
We could, for instance, have two different representations for the natural
numbers (binary and unary possibly): the univalence axiom allows us to say ``all
of the things we have proven about the unary numbers are also true about the
binary numbers''.
This is an essential technique in most areas of mathematics, which
had no useful analogue in type theory until recently.

All of our work will be formalised in Agda
\citep{norellDependentlyTypedProgramming2008}, a
dependently typed, pure, functional programming language which can be
used as a proof assistant.
Proofs in Agda are programs which can be run: its syntax is quite similar to
Haskell's.
A recent extension to Agda, Cubical Agda
\citep{vezzosiCubicalAgdaDependently2019}, allows Agda to compile and typecheck
programs written in Cubical Type Theory \citep{cohenCubicalTypeTheory2016}: this
type theory gives a \emph{computational} interpretation of the univalence axiom.

This thesis is aimed at individuals with some knowledge of Haskell (although
extensive knowledge of Haskell is not an absolute necessity) and a curiosity
about dependent types.
We will explain the basics of dependently-typed programming in Agda, how to
write programs and how to write proofs, and we will explain something of the
internals of dependent type theory along the way.
\section{Overview}
This thesis is structured as follows: in Chapter~\ref{agda-intro} we will
introduce Agda, its syntax, and quickly bring reader up to speed with how to
write programs in it.
We will also begin to talk about some more foundational type-theory concepts,
and we will explain a little about Agda's particular interpretation of HoTT and
CuTT.
As we mentioned, some programming experience in Haskell is useful, although not
strictly speaking necessary.
Certainly no knowledge of dependent type theory is required.

In Chapter~\ref{finiteness-predicates} we will look in-depth at the focus of
this thesis: finiteness.
As mentioned finiteness in constructive mathematics is a good deal more complex
than finiteness classically:
in this thesis along we will see five separate definitions of ``finiteness'',
each different, and each with reasonable claim to being the ``true'' definition
of finiteness.
We will see which predicates imply each other, what extra information we can
derive from the predicates, and what types are included or excluded from each.
Along the way we will learn a little more about HoTT and univalence, and we'll
see some practical and direct uses of the univalence axiom.

In Chapter~\ref{topos} we will look a little at a slightly more advanced
application of HoTT: topos theory.
A topos is quite a complex, abstract object: it behaves something like the
category of sets, although it is more general.
For us, showing that sets in Homotopy Type Theory form a topos (well, nearly)
will give us access to the general language of toposes.

In Chapter~\ref{search} we will combine everything from the previous chapters
into a (somewhat) practical program for proof search.
This program will automatically search for, and attempt to prove, a simple
proposition.
We will demonstrate the program with the countdown problem
\citep{huttonCountdownProblem2002}: this is a somewhat famous puzzle where
players are given five numbers and a target, and have to construct an expression
using some or all of the supplied numbers which evaluates to the target.

Finally, in Chapter~\ref{infinite} we will see how we can adapt the work of
previous chapters to the setting of countably infinite types.
Countably infinite are those types that have a bijection with the natural
numbers: we will see that we can develop a similar framework of proofs for them
as we did for the finite types (with some important differences).
\section{What is a Proof?}
Constructive mathematics is, fundamentally, a different way of thinking about
proofs.
Classically we have two fundamentally different universes of things: we have
objects, like the natural numbers, or the rings; and the proofs on those things.
Constructive mathematics is an effort to join those two worlds together.

Practically speaking this means that in constructive mathematics we can't
always ``prove the existence of'' some thing; instead we simply provide that
thing.
We mentioned an example where this comes into play: to prove that something is
finite we might want to prove that it is in bijection with some other finite
type.
Constructively, this proof \emph{is} a bijection.

Constructive mathematics is also deeply tied to computers.
Dependently-typed programming languages, like Agda
\citep{norellDependentlyTypedProgramming2008}, Coq
\citep{thecoqdevelopmentteamCoqProofAssistant2020}, or Idris
\citep{bradyIdrisGeneralpurposeDependently2013}, allow us to compile and
\emph{run} our proofs.
If we provide a bijection between two types in Agda we also provide a function
to and from each type.
Agda is therefore both a formal language for constructive proofs and a
programming language which can run those proofs.

All of the extra capabilities of constructive mathematics do not come for free,
of course.
Occasionally we don't want to provide the extra information that
constructiveness demands: later, for instance, we will begin to work with the
category of finite sets.
The objects of this category are (of course) finite sets: however, if our notion
of ``finite'' is tied to an explicit bijection, that means that the type of
``things which are finite'' is pairs of types and bijections between those
types. 
Since there are \(n!\) bijections between a type of cardinality \(n\) and any
other, this means that for every such type we have \(n!\) different objects,
instead of just 1.
We'll see a way to fix this problem with Homotopy Type Theory.

The proofs we will provide in this thesis will be written in the syntax of
Agda: they are, however, all valid classical proofs.
Constructive mathematics is a subset of classical, after all.
When we say ``constructive'' we really just mean that these proofs avoid
reliance on certain axioms like the law of the excluded middle, or the axiom of
choice.

\section{Homotopy Type Theory}
% We are interested in constructive notions of finiteness, formalised in Cubical
% Type Theory
% In this paper we will explore five such notions of finiteness, including their
% categorical interpretation, and use them to build a simple proof-search library
% facilitated in a fundamental way by univalence.
% Along the way we will use the Countdown
% problem as an example, and provide a program
% which produces verified solutions to the puzzle.
% We will also briefly examine countability, and demonstrate its parallels and
% differences with finiteness.
% \section{The Varieties of Finiteness}
% \todo{Make all references parenthetical}
% In Section~\ref{finiteness-predicates} we will explore a number of different
% predicates for finiteness.
% In contrast to classical finiteness, in a constructive setting there are many
% predicates which all have some claim to being the formal interpretation of
% ``finiteness''~\citep{coquandConstructivelyFinite2010}.
% The particular predicates we are interested in are organised in
% Figure~\ref{finite-classification}: each arrow in the diagram represents a proof
% that one predicate can be derived from another.
% Each arrow in Figure~\ref{finite-classification} corresponds to a proof of
% implication: cardinal finiteness, for instance, with a strict total order,
% implies split enumerability (Theorem~\ref{cardinal-to-manifest-bishop}).


% These finiteness predicates differ along two main axes: informativeness, and
% restrictiveness.
% More ``informative'' predicates have proofs which contain extraneous information
% other than the finiteness of the underlying type: a proof of split enumerability
% (Section~\ref{split-enumerability}), for instance, comes with a strict total
% order on the underlying type.

% The ``restrictiveness'' of a predicate refers to how many types it admits into
% its notion of ``finite''.
% There are strictly more Kuratowski finite (Section~\ref{kuratowski}) types than
% there are Cardinally finite (Section~\ref{cardinal-finiteness}).

% Proofs coming with extra information is a common theme in constructive
% mathematics: often this extra information is in the form of an algorithm which
% can do something useful related to the proof itself.
% Indeed, our proofs of finiteness here will provide an algorithm to solve the
% countdown puzzle.
% Occasionally, however, the extra information is undesirable: we may want to
% assert the existence of some value \(x : A\) which satisfies a predicate \(P\)
% without revealing \emph{which} \(A\) we're referring to.
% More concretely, we will need in this paper to prove that two types are in
% bijection without specifying a particular bijection.
% This facility is provided by Homotopy Type Theory~\citep{hottbook} in the form of
% propositional truncation, and it is what allows us to prove the bulk of
% propositions in this paper.

% For each predicate we will also prove its closure properties (i.e.\ that the
% product of two finite sets is finite).
% The most significant of these closure proofs is that of closure under \(\Pi\)
% (dependent functions) (Theorem~\ref{split-enum-pi}).
% \section{Toposes and Finite Sets}
% In Section~\ref{topos}, we will explore the categorical interpretation of
% decidable Kuratowski finite sets.
% The motivation here is partially a practical one: by the end of this work we
% will have provided a library for proof search over finite types, and the
% ``language'' of a topos is a reasonable choice for a principled language for
% constructing proofs of finiteness in the style of
% QuickCheck~\citep{claessenQuickCheckLightweightTool2011} generators.

% Theoretically speaking, showing that sets in Homotopy Type Theory form a topos
% (with some caveats) is an important step in characterising the categorical
% implications of Homotopy Type Theory, first proven
% in~\citep{rijkeSetsHomotopyType2015}. \todo{This reference should be citet not citep}
% Our work is a formalisation of this result (and the first such formalisation
% that we are aware of).
% The proof that decidable Kuratowski finite sets form a \(\Pi\)-pretopos is
% additional to that.
% \section{Countability Predicates}
% After the finite predicates, we will briefly look at the infinite countable
% types, and classify them in a parallel way to the finite predicates
% (Section~\ref{infinite}).
% We will see that we lose closure under function arrows, but we gain it under the
% Kleene star (Theorem~\ref{split-countability-sigma}).
% \section{Search}
% All of our work is formalised in Cubical
% Agda~\citep{vezzosiCubicalAgdaDependently2019}: as a result, the constructive
% interpretation of each proof is actually a program which can be run on a
% computer.
% In finiteness in particular, these programs are particularly useful for
% exhaustive search.

% We will use the countdown problem as a running example throughout the paper: we
% will show how to prove that any given puzzle has a finite number of solutions,
% and from that we will show how to enumerate those solutions, thereby solving the
% puzzle in a verified way.

% In Section~\ref{search} we will package up the ``search'' aspect of finiteness
% into a library for proof search: similar libraries have been built
% in~\citep{fruminFiniteSetsHomotopy2018}
% and~\citep{firsovDependentlyTypedProgramming2015}.
% Our library differs from those in three important ways: firstly, it is strictly
% more powerful, as it allows for search over function types.
% Secondly, finiteness proofs also provide equivalence proofs to any other finite
% type: this allows transport of proofs between types of the same cardinality.
% Finally, through generic programming we provide a simple syntax for stating
% properties which mimics that of QuickCheck.
% We also ground the library in the theoretical notions of omniscience.
% \section{Notation and Background}
% We work in Cubical Type Theory~\citep{cohenCubicalTypeTheory2016}, specifically
% Cubical Agda~\citep{vezzosiCubicalAgdaDependently2019}.
% Cubical Agda is a dependently-typed functional programming language, based on
% Martin-Löf Intuitionistic Type Theory, with a Haskell-like syntax.

% Being a dependently-typed language, we'll have to be clear about what we mean
% when we say ``type'' in Agda.
% \begin{definition}[Type]
%   We use \(\AgdaDatatype{Type}\) to denote the universe of (small) types.
%   The universe level is denoted with a subscript number, starting at 0.
%   ``Type families'' are functions into \(\AgdaDatatype{Type}\).
% \end{definition}

% The are two broad ways to define types in Agda: as an inductive
% \(\AgdaKeyword{data}\) type, similar to data type definitions in Haskell, or as
% a \(\AgdaKeyword{record}\).
% Here we'll define the basic type formers used in MLTT.\@
% \begin{definition}[Basic Types]
%   The three basic types---often called 0, 1, and 2 in MLTT---here will be
%   denoted with their more common names: \(\bot\), \(\top\), and
%   \(\mathbf{Bool}\), respectively.
%   \begin{multicols}{3}
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{bot}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{top}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{bool}
%     \end{agdalisting*}
%   \end{multicols}
% \end{definition}
% \begin{definition}[The Dependent Sum]
%   Dependent sums are denoted with the usual \(\Sigma\) symbol, and has the
%   following definition in Agda:

%   \begin{agdalisting*}
%     \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma}
%   \end{agdalisting*}
%   We will use different notations to refer to this type depending on the
%   setting.
%   The following four expressions all denote the same type:

%   \begin{multicols}{4}
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-1}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-3}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-4}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-2}
%     \end{agdalisting*}
%   \end{multicols} \vspace{-1\baselineskip} \noindent
%   The non-dependent product is a special instance of the dependent.
%   We denote a simple pair of types \(A\) and \(B\) as \(A \times B\).
% \end{definition}
% \begin{definition}[Dependent Product]
%   Dependent products (dependent functions) use the \(\Pi\) symbol.
%   The three following expressions all denote the same type:
%   \begin{multicols}{3}
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{pi-syntax-1}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{pi-syntax-2}
%     \end{agdalisting*} \columnbreak
%     \begin{agdalisting*}
%       \ExecuteMetaData[agda/Snippets/Introduction.tex]{pi-syntax-3}
%     \end{agdalisting*}
%   \end{multicols}\vspace{-1.5\baselineskip}\noindent
%   Non-dependent functions are denoted with the arrow (\(\rightarrow\)).
% \end{definition}

% At this point, as a quick example, we can define the first of our objects for
% the countdown transformation: the vector of Booleans for selection.
% A vector is relatively simple to define: a vector of zero elements is simply a
% unit, a vector of \(n+1\) elements is the product of an element and a vector of
% \(n\) elements.
% \begin{agdalisting*}
%   \ExecuteMetaData[agda/Data/Vec/Iterated.tex]{vec-def}
% \end{agdalisting*}
% From this we can see that a vector of \(n\) Booleans has the type
% \(\AgdaDatatype{Vec} \; \AgdaDatatype{Bool} \; n\)

% Finally, there is one last thing we must define before moving on to the
% finiteness predicates: paths.
% \begin{definition}[Path Types]\label{path-types}
%   The equality type (which we denote with \(\equiv\)) in CuTT is the type of
%   Paths\footnotemark.
%   The nature and internal structure of Paths is complex and central to how
%   Cubical Type Theory ``implements'' Homotopy Type Theory, but those details are
%   not relevant to us here.
%   Instead, we only need to know that univalence holds for paths, and path types
%   do indeed compute in Cubical Agda.
% \end{definition}

% \footnotetext{%
%   Actually, CuTT does have an identity type with similar semantics to the
%   identity type in MLTT.\@
%   We do not use this type anywhere in our work, however, so we will not consider
%   it here.
% }

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
