\chapter{Programming and Proving in Cubical Agda}
Agda \cite{norellDependentlyTypedProgramming2008} is a dependently-typed
functional programming language.
A recent extension to the language, Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}, allows us to do Cubical Type Theory
directly in Agda.

In this chapter we will go through a basic example to explain the fundamentals
of programming in Agda, and we will begin to explain some cubical type theory
features.
\section{Basic Functional Programming in Agda}
The basic unit of functionality in Agda is the \emph{type}.
We can define types like so:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-def}
\end{agdalisting}
Here we've defined the type of booleans.
The first line of this definition states the name of the type, and also tells us
that \AgdaDatatype{Bool} is a \AgdaDatatype{\(\text{Type}_0\)}.
The subscripted index is the universe level of the type: we won't go into the
details of universe levels now (and in fact almost all types we will work with
have level 0, so it won't come up very much), but we will mention that they are
related to Girard's paradox.
\cite{girardInterpretationFonctionelleElimination1972}.

\begin{marginagdalisting}{A Boolean Value}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-val}
\end{marginagdalisting} \todo{Better as inline/margin?}
This type has two inhabitants: \AgdaInductiveConstructor{false}, and
\AgdaInductiveConstructor{true}.
We can construct values of the type by referring to one of these two
inhabitants.
And we can further define functions by \emph{pattern-matching} on these
inhabitants:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{not-def}
\end{agdalisting}
\section{An Expression Evaluator}
Later we will builder a verified solver for the Countdown problem
\cite{huttonCountdownProblem2002} \todo{Find original reference for this}, for
now we will look at building a small part of the solution: an expression
evaluator.
Along the way, we will see how to implement some common functional programming
idioms in Agda (with some small improvements over Haskell when it comes to
syntax), and we will see how dependent types can give us a slightly nicer
interface than normal.

First, we'll need to define the natural numbers:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Nat.tex]{nat-def}
\end{agdalisting}
In contrast to \AgdaDatatype{Bool}, we haven't simply listed the inhabitants of
this type, as that would somewhat bloat the page count of this thesis.
Instead, we list the \emph{ways} to construct elements of the type.
First, we say that you can create a natural number called
\AgdaInductiveConstructor{zero}.
Then, we say if you already have a natural number, than you can create its
successor, using \AgdaDatatype{suc}.
For now, we can think of inductive type definitions in Agda as being:
\begin{enumerate}
  \item A type name.
  \item A kind (i.e. \AgdaFunction{\(\text{Type}_0\)}).
  \item A list of constructors, which are functions whose return types are the
    type being defined.
\end{enumerate}
We will see later that this isn't the entire story, but it is a good enough
intuition for now.

Of course we can also define functions on the natural numbers, in much the same
way as we did on the booleans:
\begin{agdalisting} \label{sub-def}
  \ExecuteMetaData[agda/Snippets/Nat.tex]{sub-def}
\end{agdalisting}
Here we've defined subtraction.

We want to define a language of arithmetic expressions.
With countdown in mind, we'll only need to support four operators, which we can
define in a simple data type:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{op-def}
\end{agdalisting}

Next, we'll define the actual type of expressions.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{expr-def}
\end{agdalisting}
What we've defined here is actually a simple leafy binary tree.
The syntax for the second constructor is not so simple, however: it defines a
\emph{mixfix} operator.
Each underscore in \AgdaInductiveConstructor{\(\_\langle \_ \rangle\_\)}
represents a hole which expressions can be put into.
This allows us to use the constructor like so:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{example-expr}
\end{agdalisting}
\section{Safe Evaluation With Monads}
The next step is to write the evaluator for the type we have defined above.
There is a slight complication, however: some definable expressions don't have
defined evaluations.
Take the subtraction as defined on natural numbers, for instance
(Listing~\ref{sub-def}).
We really shouldn't be able to subtract a larger number from a smaller one, and
we would like to use the type system to prevent us from doing this.

The most common technique to solve this problem uses \AgdaDatatype{Maybe}:
\begin{agdalisting}
  \ExecuteMetaData[agda/Data/Maybe/Base.tex]{maybe-def}
\end{agdalisting}
This is the first \emph{parameterised} type we have seen: \AgdaDatatype{Maybe}
is a container with one or zero elements, but we haven't specified which type
can inhabit it.
It can actually be specialised to any type when we use it.
For our use, we will specialise it to \agdambb{N}:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{eval-ty}
\end{agdalisting}

We will define this function by pattern-matching.
The first case is relatively simple:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{lit-case}
\end{agdalisting}

The second two cases are slightly more complex: because we need to recursively
evaluate the subtrees of the expression in each case, we will need to check that
each of those returns a \AgdaInductiveConstructor{just} value before applying
the operator.
Luckily, we can use Agda's built-in idiom brackets to make this definition
a little cleaner: \todo{More explanation here}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{appl-cases}
\end{agdalisting}

Next, we will define subtraction.
As pointed out already, in this case we have to check to make sure that the
subtraction is valid.
Like Haskell, Agda supports do notation for this case:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{sub-case}
\end{agdalisting}

Finally, we will handle the division case.
Here, we want to pattern-match on the returned value of the recursive call.
Agda also provides syntax for that:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{div-case}
\end{agdalisting}
\todo{expand on monads applicatives etc in this section}
\section{Statically Proving the Evaluation is Safe}
Using this evaluator in practice can be a little annoying:
because it always returns a \AgdaDatatype{Maybe}, simple expressions which are
obviously valid still need to be checked at run-time.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{example-eval}
\end{agdalisting}
This is where Agda can add a little to the usual example for monads of an
expression evaluator: using dependent types, we can actually statically (and
automatically) prove that a given expression is valid, and evaluate it without
checking for \AgdaInductiveConstructor{nothing} safely.

First, we will need the following function:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{is-just}
\end{agdalisting}
This simple function can tell us if the result of evaluating an expression is
successful or not.
In other words, it can test if an expression is valid.

To use this statically, however, we will need to employ the following
\emph{dependent} function:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{tee}
\end{agdalisting}
This function turns our boolean values into types: \agdatop (tautology), or
\agdabot (impossibility).
These types are defined like so:
\begin{multicols}{2}
  \begin{agdalisting*}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{bot}
  \end{agdalisting*}  \columnbreak
  \begin{agdalisting*}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{top}
  \end{agdalisting*}
\end{multicols}
The first type here, \agdabot, has no constructors: there are no values which
inhabit the type \agdabot.
Logically speaking, it is the type of falsehoods.
It is quite useful in practice: any function of type \(A \rightarrow \agdabot\)
we know can never return, so we know that it must be impossible to call such a
function.
In other words, the type \(A\) must not have any values which inhabit it.
As such, we can use \agdabot to define a notion of ``not'' for types:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Introduction.tex]{not}
\end{agdalisting}

The second type, \agdatop, is a \AgdaKeyword{record}.
Types defined using \AgdaKeyword{record} are much more like classes or structs
in imperative programming language: instead of listing the constructors, we list
the \emph{fields} of these types.

Of course, in this case, our type doesn't have any fields.
Perhaps a more instructive example of a record is the following:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{pair}
\end{agdalisting}
Here we've defined the type of \emph{pairs}.

Types defined with \AgdaKeyword{data} and types defined with
\AgdaKeyword{record} are in some sense duals of each other: to \emph{consume} a
\AgdaKeyword{data} type, we have to handle each of the constructors; to \emph{construct}
a \AgdaKeyword{record} type, we have to handle each of the fields.
Another way to say this same thing is that \AgdaKeyword{data} types are sum
types, and \AgdaKeyword{record} types are products.
What we have in \agdabot and \agdatop is the identity for sums and products,
respectively.

Now, to be completely clear, we could absolutely have defined \agdatop as a
\AgdaKeyword{data} type with one constructor:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{data-top}
\end{agdalisting}
We use the \AgdaKeyword{record} definition simply because it tends to work a
little better in terms of ergonomics: basically, to construct a
\AgdaKeyword{record} type automatically, Agda attempts to construct all of its
\emph{fields} one by one.
Since \agdatop has no fields, this is an easy task, and hence Agda will be able
to automatically construct a value of type \agdatop in many situations
(We can ask Agda to construct something for us automatically by supplying an
underscore in place of where the value should go).
Agda is more conservative about automatically constructing \AgdaKeyword{data}
types, so there are fewer situations where it will do it automatically.
\todo{expand on this?}

So, now that we have a way of turning booleans into their logical equivalents
\todo{express this better} we can define a type for proofs that a given
expression is valid:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{valid}
\end{agdalisting}
A value of type \(\AgdaFunction{Valid}\;e\), for some expression \(e\), is a
proof that \(e\) doesn't have (for example) any divisions by zero, or
arithmetic underflows.

With this we can define a function which uses the statically provided proof in
order to rule out certain cases in a pattern-match, thereby giving us a function
which statically evaluates expressions without using a \AgdaDatatype{Maybe}:
\todo{still have to explain here implicit arguments, ``with'', etc}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{static-eval}
\end{agdalisting}
Notice here that the \AgdaFunction{Valid} proof is provided automatically,
enabled by the fact that we defined \agdatop as a record.

And with that we can statically evaluate expressions like so:
\begin{agdalisting} \label{example-static-eval}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{example-static-eval}
\end{agdalisting}
\section{Equalities}
We actually have encountered our first ``proof'' with dependent types: we have
proven that a given expression is valid or not.
Now we're going to look at another kind of proof: one that shows that an
expression is \emph{equal} to something.
To do so we'll first have to explore path types in Cubical Agda.
\begin{definition}[Path Types]
  A proof that two values are equal in Cubical Agda is represented by a
  \emph{path}.
  This path will be denoted with the symbol \AgdaFunction{\(\equiv\)}.
  In other words, a value of type \(x\;\AgdaFunction{\(\equiv\)}\;y\) is a proof
  that \(x\) equals \(y\).
\end{definition}

Equalities as paths is the first topic we have reached where Cubical Type Theory
begins to differ from traditional Martin-Löf Type Theory.
There, we would usually define the type of proofs of equality like so:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Equality.tex]{equality-def}
\end{agdalisting}
This is an inductive \AgdaKeyword{data} type, with one constructor: the
constructor can only be used when the two parameters to the type are the same,
meaning a value of this type contains a proof that they are the same.
We can retrieve this proof by pattern-matching on that constructor.

This is actually a perfectly usable equality type in CuTT: although the
elimination rule is a little complex and we won't look into it just yet.
However we prefer to represent equalities in a slightly more primitive way, as
it turns out to be a little more flexible.
This is the \emph{path} representation.

When represented as a path, an equality between two values of type \(A\)
actually behaves more like a function from \AgdaDatatype{I} to \(A\).
\AgdaDatatype{I} here is the type of the interval: it ranges from
\AgdaInductiveConstructor{i0} to \AgdaInductiveConstructor{i1}.
So, as a function then, when the path \(x\;\AgdaFunction{\(\equiv\)}\;y\) is
applied to \AgdaInductiveConstructor{i0}, it returns \(x\), and when it is
applied to \AgdaInductiveConstructor{i1}, it returns \(y\).

Already we can manipulate paths in some interesting ways.
First, we can manipulate values in the interval: we can take the inverse of a
point in the interval, for instance.
It's worth thinking about what this ``inverse'' corresponds to in the equality:
we will name it in the next listing.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Equality.tex]{sym-def}
\end{agdalisting}
We will see some more intricate ways to manipulate paths later on, but for now
the ``function from an interval'' intuition is enough to understand the basics.
\section{Some Proofs of Equality}
So now that we know something about the equality type, let's put it to some use.
We can construct equality proofs of things which are ``obviously equal'' with
the following function:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Equality.tex]{refl-def}
\end{agdalisting}
With this we can prove that the output from Equation.~\ref{example-static-eval}
is 8:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{example-static-proof}
\end{agdalisting}

Of course, these proofs aren't very interesting.
Something a little more complex might be the following:
\begin{agdalisting}
  \ExecuteMetaData[agda/Data/Nat/Properties.tex]{plus-assoc}
\end{agdalisting}
Unfortunately we can't look at much more complex proofs without building up some
more machinery around path types: we can't currently compose paths, for
instance.
% \section{Quotients}
% We've seen that data types can be defined by listing their constructors, where
% each constructor is just a function whose return type is the type being defined.
% However, we've also seen that 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: