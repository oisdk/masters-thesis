\chapter{Programming and Proving in Cubical Agda}
Agda \cite{norellDependentlyTypedProgramming2008} is a dependently-typed
functional programming language.
A recent extension to the language, Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}, allows us to do Cubical Type Theory
directly in Agda.

In this chapter we will go through a basic example to explain the fundamentals
of programming in Agda, and we will begin to explain some cubical type theory
features.
\section{Basic Functional Programming in Agda}
The basic unit of functionality in Agda is the \emph{type}.
We can define types like so:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-def}
\end{agdalisting}
Here we've defined the type of booleans.
The first line of this definition states the same of the type, and also tells us
that \AgdaDatatype{Bool} is a \AgdaDatatype{\(\text{Type}_0\)}.
The subscripted index is the universe level of the type: we won't go into the
details of universe levels now (and in fact almost all types we will work with
have level 0, so it won't come up very much), but we will mention that they are
related to Girard's paradox.
\cite{girardInterpretationFonctionelleElimination1972}.

This type has two inhabitants: \AgdaInductiveConstructor{false}, and
\AgdaInductiveConstructor{true}.
We can construct values of the type by referring to one of these two
inhabitants:
\begin{marginagdalisting}{A Boolean Value}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-val}
\end{marginagdalisting} \todo{Better as inline/margin?}
And we can further define functions by \emph{pattern-matching} on these
inhabitants:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{not-def}
\end{agdalisting}
\section{An Expression Evaluator}
Later we will builder a verified solver for the Countdown problem
\cite{huttonCountdownProblem2002} \todo{Find original reference for this}, for
now we will look at building a small part of the solution: an expression
evaluator.
Along the way, we will see how to implement some common functional programming
idioms in Agda (with some small improvements over Haskell when it comes to
syntax), and we will see how dependent types can give us a slightly nicer
interface than normal.

First, we'll need to define the natural numbers:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Nat.tex]{nat-def}
\end{agdalisting}
In contrast to \AgdaDatatype{Bool}, we haven't simply listed the inhabitants of
this type, as that would somewhat bloat the page count of this thesis.
Instead, we list the \emph{ways} to construct elements of the type.
First, we say that you can create a natural number called
\AgdaInductiveConstructor{zero}.
Then, we say if you already have a natural number, than you can create its
successor, using \AgdaDatatype{suc}.
For now, we can think of inductive type definitions in Agda as being:
\begin{enumerate}
  \item A type name.
  \item A kind (i.e. \AgdaFunction{\(\text{Type}_0\)}).
  \item A list of constructors, which are functions whose return types are the
    type being defined.
\end{enumerate}
We will see later that this isn't the entire story, but it is a good enough
intuition for now.

Of course we can also define functions on the natural numbers, in much the same
way as we did on the booleans:
\begin{agdalisting} \label{sub-def}
  \ExecuteMetaData[agda/Snippets/Nat.tex]{sub-def}
\end{agdalisting}
Here we've defined subtraction.

We want to define a language of arithmetic expressions.
With countdown in mind, we'll only need to support four operators, which we can
define in a simple data type:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{op-def}
\end{agdalisting}

Next, we'll define the actual type of expressions.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{expr-def}
\end{agdalisting}
What we've defined here is actually a simple leafy binary tree.
The syntax for the second constructor is not so simple, however: it defines a
\emph{mixfix} operator.
Each underscore in \AgdaInductiveConstructor{\(\_\langle \_ \rangle\_\)}
represents a hole which expressions can be put into.
This allows us to use the constructor like so:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{example-expr}
\end{agdalisting}
\section{Safe Evaluation With Monads}
The next step is to write the evaluator for the type we have defined above.
There is a slight complication, however: some definable expressions don't have
defined evaluations.
Take the subtraction as defined on natural numbers, for instance
(Listing~\ref{sub-def}).
We really shouldn't be able to subtract a larger number from a smaller one, and
we would like to use the type system to prevent us from doing this.

The most common technique to solve this problem uses \AgdaDatatype{Maybe}:
\begin{agdalisting}
  \ExecuteMetaData[agda/Data/Maybe/Base.tex]{maybe-def}
\end{agdalisting}
This is the first \emph{parameterised} type we have seen: \AgdaDatatype{Maybe}
is a container with one or zero elements, but we haven't specified which type
can inhabit it.
It can actually be specialised to any type when we use it.
For our use, we will specialise it to \agdambb{N}:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{eval-ty}
\end{agdalisting}

We will define this function by pattern-matching.
The first case is relatively simple:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{lit-case}
\end{agdalisting}

The second two cases are slightly more complex: because we need to recursively
evaluate the subtrees of the expression in each case, we will need to check that
each of those returns a \AgdaInductiveConstructor{just} value before applying
the operator.
Luckily, we can use Agda's built-in idiom brackets to make this definition
a little cleaner: \todo{More explanation here}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{appl-cases}
\end{agdalisting}

Next, we will define subtraction.
As pointed out already, in this case we have to check to make sure that the
subtraction is valid.
Like Haskell, Agda supports do notation for this case:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{sub-case}
\end{agdalisting}

Finally, we will handle the division case.
Here, we want to pattern-match on the returned value of the recursive call.
Agda also provides syntax for that:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{div-case}
\end{agdalisting}
\todo{expand on monads applicatives etc in this section}
\section{Statically Proving the Evaluation is Safe}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{is-just}
\end{agdalisting}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{valid}
\end{agdalisting}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{from-just}
\end{agdalisting}
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Expr.tex]{static-eval}
\end{agdalisting}
\section{Quotienting the Expression}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: